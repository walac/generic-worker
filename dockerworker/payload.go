// +build docker
// This source code file is AUTO-GENERATED by github.com/taskcluster/jsonschema2go

package dockerworker

import (
	"encoding/json"

	tcclient "github.com/taskcluster/taskcluster-client-go"
)

type (
	Artifact struct {
		Expires tcclient.Time `json:"expires,omitempty"`

		Path string `json:"path"`

		// Possible values:
		//   * "file"
		//   * "directory"
		Type string `json:"type"`
	}

	// Set of capabilities that must be enabled or made available to the task container Example: ```{ "capabilities": { "privileged": true }```
	Capabilities struct {

		// Allows devices from the host system to be attached to a task container similar to using `--device` in docker.
		Devices Devices `json:"devices,omitempty"`

		// Allows a task to run in a privileged container, similar to running docker with `--privileged`.  This only works for worker-types configured to enable it.
		//
		// Default:    false
		Privileged bool `json:"privileged,omitempty"`
	}

	// Allows devices from the host system to be attached to a task container similar to using `--device` in docker.
	Devices struct {

		// Audio loopback device created using snd-aloop
		LoopbackAudio bool `json:"loopbackAudio,omitempty"`

		// Video loopback device created using v4l2loopback.
		LoopbackVideo bool `json:"loopbackVideo,omitempty"`
	}

	// Image to use for the task.  Images can be specified as an image tag as used by a docker registry, or as an object declaring type and name/namespace
	DockerImageArtifact struct {
		Path string `json:"path"`

		TaskID string `json:"taskId"`

		// Possible values:
		//   * "task-image"
		Type string `json:"type"`
	}

	// Image to use for the task.  Images can be specified as an image tag as used by a docker registry, or as an object declaring type and name/namespace
	DockerImageName string

	// `.payload` field of the queue.
	DockerWorkerPayload struct {

		// Artifact upload map example: ```{"public/build.tar.gz": {"path": "/home/worker/build.tar.gz", "expires": "2016-05-28T16:12:56.693817Z", "type": "file"}}```
		Artifacts map[string]Artifact `json:"artifacts,omitempty"`

		// Caches are mounted within the docker container at the mount point specified. Example: ```{ "CACHE NAME": "/mount/path/in/container" }```
		//
		// Map entries:
		Cache map[string]string `json:"cache,omitempty"`

		// Set of capabilities that must be enabled or made available to the task container Example: ```{ "capabilities": { "privileged": true }```
		Capabilities Capabilities `json:"capabilities,omitempty"`

		// Example: `['/bin/bash', '-c', 'ls']`.
		//
		// Default:    []
		//
		// Array items:
		Command []string `json:"command,omitempty"`

		// List of base64 encoded asymmetric encrypted environment variables. See /docs/reference/workers/docker-worker/environment#encrypted-environment-variables
		//
		// Array items:
		EncryptedEnv []string `json:"encryptedEnv,omitempty"`

		// Example: ```
		// {
		//   "PATH": '/borked/path'
		//   "ENV_NAME": "VALUE"
		// }
		// ```
		//
		// Map entries:
		Env map[string]string `json:"env,omitempty"`

		// Used to enable additional functionality.
		Features FeatureFlags `json:"features,omitempty"`

		// Image to use for the task.  Images can be specified as an image tag as used by a docker registry, or as an object declaring type and name/namespace
		//
		// One of:
		//   * DockerImageName
		//   * NamedDockerImage
		//   * IndexedDockerImage
		//   * DockerImageArtifact
		Image json.RawMessage `json:"image"`

		// Specifies a custom location for the livelog artifact
		Log string `json:"log,omitempty"`

		// Maximum time the task container can run in seconds
		//
		// Mininum:    1
		// Maximum:    86400
		MaxRunTime float64 `json:"maxRunTime"`

		// By default docker-worker will fail a task with a non-zero exit status without retrying.  This payload property allows a task owner to define certain exit statuses that will be marked as a retriable exception.
		OnExitStatus ExitStatusHandling `json:"onExitStatus,omitempty"`

		// Syntax:     ^https?://[\x20-\x7e]*$
		SupersederURL string `json:"supersederUrl,omitempty"`
	}

	// By default docker-worker will fail a task with a non-zero exit status without retrying.  This payload property allows a task owner to define certain exit statuses that will be marked as a retriable exception.
	ExitStatusHandling struct {

		// If the task exists with a purge caches exit status, all caches associated with the task will be purged.
		//
		// Array items:
		PurgeCaches []float64 `json:"purgeCaches,omitempty"`

		// If the task exists with a retriable exit status, the task will be marked as an exception and a new run created.
		//
		// Array items:
		Retry []float64 `json:"retry,omitempty"`
	}

	// Used to enable additional functionality.
	FeatureFlags struct {

		// This allows you to use the Linux ptrace functionality inside the container; it is otherwise disallowed by Docker's security policy.
		AllowPtrace bool `json:"allowPtrace,omitempty"`

		Artifacts bool `json:"artifacts,omitempty"`

		// The Balrog stage proxy feature allows tasks to make requests to http://balrog which is a proxied connection through a vpn tunnel to the stage balrog update server.
		BalrogStageVPNProxy bool `json:"balrogStageVPNProxy,omitempty"`

		// The Balrog proxy feature allows tasks to make requests to http://balrog which is a proxied connection through a vpn tunnel to production balrog update server.
		BalrogVPNProxy bool `json:"balrogVPNProxy,omitempty"`

		// Useful if live logging is not interesting but the overalllog is later on
		BulkLog bool `json:"bulkLog,omitempty"`

		// An artifact named chainOfTrust.json.asc should be generated which will include information for downstream tasks to build a level of trust for the artifacts produced by the task and the environment it ran in.
		ChainOfTrust bool `json:"chainOfTrust,omitempty"`

		// Runs docker-in-docker and binds `/var/run/docker.sock` into the container. Doesn't allow privileged mode, capabilities or host volume mounts.
		Dind bool `json:"dind,omitempty"`

		// Uploads docker images as artifacts
		DockerSave bool `json:"dockerSave,omitempty"`

		// This allows you to interactively run commands inside the container and attaches you to the stdin/stdout/stderr over a websocket. Can be used for SSH-like access to docker containers.
		Interactive bool `json:"interactive,omitempty"`

		// Logs are stored on the worker during the duration of tasks and available via http chunked streaming then uploaded to s3
		LocalLiveLog bool `json:"localLiveLog,omitempty"`

		// The Releng API proxy service allows tasks to talk to releng api using an authorization token based on the task's scopes
		RelengAPIProxy bool `json:"relengAPIProxy,omitempty"`

		// The auth proxy allows making requests to taskcluster/queue and taskcluster/scheduler directly from your task with the same scopes as set in the task. This can be used to make api calls via the [client](https://github.com/taskcluster/taskcluster-client) CURL, etc... Without embedding credentials in the task.
		TaskclusterProxy bool `json:"taskclusterProxy,omitempty"`
	}

	// Image to use for the task.  Images can be specified as an image tag as used by a docker registry, or as an object declaring type and name/namespace
	IndexedDockerImage struct {
		Namespace string `json:"namespace"`

		Path string `json:"path"`

		// Possible values:
		//   * "indexed-image"
		Type string `json:"type"`
	}

	// Image to use for the task.  Images can be specified as an image tag as used by a docker registry, or as an object declaring type and name/namespace
	NamedDockerImage struct {
		Name string `json:"name"`

		// Possible values:
		//   * "docker-image"
		Type string `json:"type"`
	}
)

// Returns json schema for the payload part of the task definition. Please
// note we use a go string and do not load an external file, since we want this
// to be *part of the compiled executable*. If this sat in another file that
// was loaded at runtime, it would not be burned into the build, which would be
// bad for the following two reasons:
//  1) we could no longer distribute a single binary file that didn't require
//     installation/extraction
//  2) the payload schema is specific to the version of the code, therefore
//     should be versioned directly with the code and *frozen on build*.
//
// Run `generic-worker show-payload-schema` to output this schema to standard
// out.
func taskPayloadSchema() string {
	return `{
  "$schema": "http://json-schema.org/draft-06/schema#",
  "additionalProperties": false,
  "definitions": {
    "artifact": {
      "additionalProperties": false,
      "properties": {
        "expires": {
          "format": "date-time",
          "title": "Date when artifact should expire must be in the future.",
          "type": "string"
        },
        "path": {
          "title": "Location of artifact in container.",
          "type": "string"
        },
        "type": {
          "enum": [
            "file",
            "directory"
          ],
          "title": "Artifact upload type.",
          "type": "string"
        }
      },
      "required": [
        "type",
        "path"
      ],
      "type": "object"
    }
  },
  "description": "` + "`" + `.payload` + "`" + ` field of the queue.",
  "properties": {
    "artifacts": {
      "additionalProperties": {
        "$ref": "#/definitions/artifact"
      },
      "description": "Artifact upload map example: ` + "`" + `` + "`" + `` + "`" + `{\"public/build.tar.gz\": {\"path\": \"/home/worker/build.tar.gz\", \"expires\": \"2016-05-28T16:12:56.693817Z\", \"type\": \"file\"}}` + "`" + `` + "`" + `` + "`" + `",
      "title": "Artifacts",
      "type": "object"
    },
    "cache": {
      "additionalProperties": {
        "type": "string"
      },
      "description": "Caches are mounted within the docker container at the mount point specified. Example: ` + "`" + `` + "`" + `` + "`" + `{ \"CACHE NAME\": \"/mount/path/in/container\" }` + "`" + `` + "`" + `` + "`" + `",
      "title": "Caches to mount point mapping.",
      "type": "object"
    },
    "capabilities": {
      "additionalProperties": false,
      "description": "Set of capabilities that must be enabled or made available to the task container Example: ` + "`" + `` + "`" + `` + "`" + `{ \"capabilities\": { \"privileged\": true }` + "`" + `` + "`" + `` + "`" + `",
      "properties": {
        "devices": {
          "additionalProperties": false,
          "description": "Allows devices from the host system to be attached to a task container similar to using ` + "`" + `--device` + "`" + ` in docker. ",
          "properties": {
            "loopbackAudio": {
              "description": "Audio loopback device created using snd-aloop",
              "title": "Loopback Audio device",
              "type": "boolean"
            },
            "loopbackVideo": {
              "description": "Video loopback device created using v4l2loopback.",
              "title": "Loopback Video device",
              "type": "boolean"
            }
          },
          "title": "Devices to be attached to task containers",
          "type": "object"
        },
        "privileged": {
          "default": false,
          "description": "Allows a task to run in a privileged container, similar to running docker with ` + "`" + `--privileged` + "`" + `.  This only works for worker-types configured to enable it.",
          "title": "Privileged container",
          "type": "boolean"
        }
      },
      "title": "Capabilities that must be available/enabled for the task container.",
      "type": "object"
    },
    "command": {
      "default": [],
      "description": "Example: ` + "`" + `['/bin/bash', '-c', 'ls']` + "`" + `.",
      "items": {
        "type": "string"
      },
      "title": "Docker command to run (see docker api).",
      "type": "array"
    },
    "encryptedEnv": {
      "description": "List of base64 encoded asymmetric encrypted environment variables. See /docs/reference/workers/docker-worker/environment#encrypted-environment-variables",
      "items": {
        "title": "Base64 encoded encrypted environment variable object.",
        "type": "string"
      },
      "title": "List of encrypted environment variable mappings.",
      "type": "array"
    },
    "env": {
      "additionalProperties": {
        "type": "string"
      },
      "description": "Example: ` + "`" + `` + "`" + `` + "`" + `\n{\n  \"PATH\": '/borked/path' \n  \"ENV_NAME\": \"VALUE\" \n}\n` + "`" + `` + "`" + `` + "`" + `",
      "title": "Environment variable mappings.",
      "type": "object"
    },
    "features": {
      "additionalProperties": false,
      "description": "Used to enable additional functionality.",
      "properties": {
        "allowPtrace": {
          "description": "This allows you to use the Linux ptrace functionality inside the container; it is otherwise disallowed by Docker's security policy. ",
          "title": "Allow ptrace within the container",
          "type": "boolean"
        },
        "artifacts": {
          "description": "",
          "title": "Artifact uploads",
          "type": "boolean"
        },
        "balrogStageVPNProxy": {
          "description": "The Balrog stage proxy feature allows tasks to make requests to http://balrog which is a proxied connection through a vpn tunnel to the stage balrog update server.",
          "title": "Balrog stage proxy service",
          "type": "boolean"
        },
        "balrogVPNProxy": {
          "description": "The Balrog proxy feature allows tasks to make requests to http://balrog which is a proxied connection through a vpn tunnel to production balrog update server.",
          "title": "Balrog proxy service",
          "type": "boolean"
        },
        "bulkLog": {
          "description": "Useful if live logging is not interesting but the overalllog is later on",
          "title": "Bulk upload the task log into a single artifact",
          "type": "boolean"
        },
        "chainOfTrust": {
          "description": "An artifact named chainOfTrust.json.asc should be generated which will include information for downstream tasks to build a level of trust for the artifacts produced by the task and the environment it ran in.",
          "title": "Enable generation of a openpgp signed Chain of Trust artifact",
          "type": "boolean"
        },
        "dind": {
          "description": "Runs docker-in-docker and binds ` + "`" + `/var/run/docker.sock` + "`" + ` into the container. Doesn't allow privileged mode, capabilities or host volume mounts.",
          "title": "Docker in Docker",
          "type": "boolean"
        },
        "dockerSave": {
          "description": "Uploads docker images as artifacts",
          "title": "Docker save",
          "type": "boolean"
        },
        "interactive": {
          "description": "This allows you to interactively run commands inside the container and attaches you to the stdin/stdout/stderr over a websocket. Can be used for SSH-like access to docker containers.",
          "title": "Docker Exec Interactive",
          "type": "boolean"
        },
        "localLiveLog": {
          "description": "Logs are stored on the worker during the duration of tasks and available via http chunked streaming then uploaded to s3",
          "title": "Enable live logging (worker local)",
          "type": "boolean"
        },
        "relengAPIProxy": {
          "description": "The Releng API proxy service allows tasks to talk to releng api using an authorization token based on the task's scopes",
          "title": "Releng API proxy service",
          "type": "boolean"
        },
        "taskclusterProxy": {
          "description": "The auth proxy allows making requests to taskcluster/queue and taskcluster/scheduler directly from your task with the same scopes as set in the task. This can be used to make api calls via the [client](https://github.com/taskcluster/taskcluster-client) CURL, etc... Without embedding credentials in the task.",
          "title": "Task cluster auth proxy service",
          "type": "boolean"
        }
      },
      "title": "Feature flags",
      "type": "object"
    },
    "image": {
      "description": "Image to use for the task.  Images can be specified as an image tag as used by a docker registry, or as an object declaring type and name/namespace",
      "oneOf": [
        {
          "title": "Docker image name",
          "type": "string"
        },
        {
          "additionalProperties": false,
          "properties": {
            "name": {
              "type": "string"
            },
            "type": {
              "enum": [
                "docker-image"
              ],
              "type": "string"
            }
          },
          "required": [
            "type",
            "name"
          ],
          "title": "Named docker image",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "namespace": {
              "type": "string"
            },
            "path": {
              "type": "string"
            },
            "type": {
              "enum": [
                "indexed-image"
              ],
              "type": "string"
            }
          },
          "required": [
            "type",
            "namespace",
            "path"
          ],
          "title": "Indexed docker image",
          "type": "object"
        },
        {
          "additionalProperties": false,
          "properties": {
            "path": {
              "type": "string"
            },
            "taskId": {
              "type": "string"
            },
            "type": {
              "enum": [
                "task-image"
              ],
              "type": "string"
            }
          },
          "required": [
            "type",
            "taskId",
            "path"
          ],
          "title": "Docker image artifact",
          "type": "object"
        }
      ],
      "title": "Docker image."
    },
    "log": {
      "description": "Specifies a custom location for the livelog artifact",
      "title": "Custom log location",
      "type": "string"
    },
    "maxRunTime": {
      "description": "Maximum time the task container can run in seconds",
      "maximum": 86400,
      "minimum": 1,
      "multipleOf": 1,
      "title": "Maximum run time in seconds",
      "type": "number"
    },
    "onExitStatus": {
      "additionalProperties": false,
      "description": "By default docker-worker will fail a task with a non-zero exit status without retrying.  This payload property allows a task owner to define certain exit statuses that will be marked as a retriable exception.",
      "properties": {
        "purgeCaches": {
          "description": "If the task exists with a purge caches exit status, all caches associated with the task will be purged.",
          "items": {
            "title": "Exit statuses",
            "type": "number"
          },
          "title": "Purge caches exit status",
          "type": "array"
        },
        "retry": {
          "description": "If the task exists with a retriable exit status, the task will be marked as an exception and a new run created.",
          "items": {
            "title": "Exit statuses",
            "type": "number"
          },
          "title": "Retriable exit statuses",
          "type": "array"
        }
      },
      "title": "Exit status handling",
      "type": "object"
    },
    "supersederUrl": {
      "format": "uri",
      "pattern": "^https?://[\\x20-\\x7e]*$",
      "title": "URL of the a service that can indicate tasks superseding this one; the current taskId will be appended as a query argument ` + "`" + `taskId` + "`" + `.  The service should return an object with a ` + "`" + `supersedes` + "`" + ` key containing a list of taskIds, including the supplied taskId.  The tasks should be ordered such that each task supersedes all tasks appearing earlier in the list.  See [superseding](/docs/reference/platform/taskcluster-queue/docs/superseding) for more detail.",
      "type": "string"
    }
  },
  "required": [
    "image",
    "maxRunTime"
  ],
  "title": "Docker worker payload",
  "type": "object"
}`
}
